import numpy as np

scores = np.array([2, 4, 1, 7, 8, 3])
print(scores.ndim)

pares = scores.reshape(3, 2)
print(pares.ndim)
print(pares)

pares2 = pares.transpose()
print(pares2)

print(pares2.ravel())

pares3 = pares.copy()

pares3[0][0] = 5
print(pares3)

pares4 = pares[:] #полный срез
print(pares4)

pares4[0:2] = [[3, 5], [6, 4]]
print(pares4)

L = [23, 45, 32, 17, 700, 53]
L2 = [np.log(item) for item in L]
print(L2)

d1 = '2019-02-12'
d2 = '2019-02-20'

dt1 = np.datetime64(d1)
dt2 = np.datetime64(d2)

print(dt2 - dt1)

#Структурированный массив
print('Структурированный массив')
info = np.array([('Anna', 32, 3), ('Serg', 40, 5), ('Mike', 38, 4)], dtype=[('name', 'U10'), ('age', int), ('mark', float)])
print(info)
print(info[:2])
print(info[['age', 'mark']][1:])

#сохранение массивов в файл
np.save('info.npy', info)
info2 = np.load('info.npy')
print(info2)

np.savetxt('info.txt', L)

# ДЗ
print('\n---ДЗ---\n')

'''Загрузить из файла array_hw.npy массив и сохранить его как arr. 
Массив содержит объёмы продаж мороженого (в штуках) в 5 магазинах за одну неделю в июне (7 дней, с понедельника до воскресенья). 
В заданиях 2-5 нужно работать с массивом arr.'''
arr = np.load('array_hw.npy')
print(arr)

'''Если думать о массиве arr как о таблице, сейчас в таблице магазины идут по столбцам (1 магазин = 1 столбец, всего 5), 
а дни – по строкам (1 день = 1 строка, всего 7). 
Преобразовать массив arr таким образом, чтобы по строкам шли магазины, а по столбцам – дни (1 строка = 1 магазин). 
Сохранить изменения. Проверить, что форма массива изменилась.'''
arr = arr.transpose()
print(arr)
print(arr.shape)

'''Давайте представим, что информация по продажам обновилась: оказалось, что пятый магазин в воскресенье продал не 19 порций мороженого, 
а 25, и второй магазин продал во вторник не 55 порций, а 65. Изменить массив arr в соответствии с этой информацией.'''
arr[4][6] = 25
arr[1][1] = 65
print(arr)

'''Посчитать суммарный объём продаж мороженого по всем магазинам.'''
print(arr.sum())

'''Выгрузить обновлённый массив arr в txt-файл. Сам txt-файл загружать в систему не нужно, только написать соответствующий код в ipynb-файл.'''
#np.savetxt('array_hw_dz.txt', arr)

'''Дан массив income, содержащий значения прибыли магазина в тысячах на начало, середину и конец года, 
за четыре года подряд (значения никак не сгруппированы, можно считать, что они так выгрузились из файла). 
Изменить форму массива так, чтобы значения были сгруппированы по три значения в каждом списке внутри массива (прибыль на начало, середину и конец года).'''
income = np.array([1000, 2000, 3500, 2500, 1500, 3800, 1200, 9000, 12000, 4500, 6700, 11000])
income = income.reshape(4, 3)
print(income)

'''Создать список turnout (list, не массив), содержащий следующие значения явки на избирательные участки в процентах:
23.56, 45.78, 34.92, 57.34, 56.55, 67.23.
Создать, используя списковые включения и встроенные, не из NumPy, функции для округления, новый список turnout_r, 
который состоит из округлённых до первого знака после запятой значений явки из turnout.'''
turnout = [23.56, 45.78, 34.92, 57.34, 56.55, 67.23]
turnout_r = [round(item, 1) for item in turnout]
print(turnout_r)

'''Выполнить те же операции, что и в предыдущей задаче, но с использованием массивов и функций NumPy. 
Другими словами, создать массив turnout и на его основе создать массив turnout_r с округлёнными до первого знака значениями явки.'''
turnout = np.array(turnout)
turnout_r = [np.round(item, 1) for item in turnout]
print(turnout_r)

'''Зайдите на страницу Википедии, посвящённую Международному индексу счастья, выберите из таблицы 2012 Международный индекс счастья 
любые 5 стран и любые 3 показателя и создайте структурированный массив happy, такой, в котором есть поле «название страны» и поля для трёх выбранных показателей. 
Выберите подходящий тип для каждого поля (показателя) в массиве и учтите это при создание структурированного массива. Выведите полученный массив на экран.'''

happy = np.array([('Коста-Рика', 64.0, 7.3, 79.3),
                  ('Вьетнам',    60.4, 5.8, 75.2),
                  ('Колумбия',   59.8, 6.4, 73.7),
                  ('Белиз',      59.3, 6.5, 76.1),
                  ('Сальвадор',  58.9, 6.7, 72.2)],
                 dtype=[('title', 'U15'), ('HPI', float), ('lHappy', float), ('lLong', float)])
print(happy)

'''Сконвертируйте полученный в предыдущей задаче структурированный массив в обычный список и выведите на экран его второй элемент.'''
happy2 = happy.tolist()
print(happy2, '\n--\n', happy2[1])

'''Написать функцию build_array(), которая принимает на вход размерность квадратной матрицы (двумерного массива, в котором число строк и число столбцов совпадают) 
и создаёт единичную матрицу E (массив) соответствующей размерности. Использовать готовую функцию np.eye() нельзя, можно использовать циклы и условные конструкции.'''
def build_array(lenght):
    result = []
    for i in range(lenght):
        r1 = []
        for j in range(lenght):
            if i == j:
                r1.append(1)
            else:
                r1.append(0)
        result.append(r1)
    return np.array(result)

print(build_array(5))

'''Напишите функцию my_reshape(), которая принимает на вход массив и его новую размерность (пару чисел), и:
если указанные измерения корректны, то возвращает массив новой размерности;
если указанные измерения некорректны, то возвращает пустой массив (пример: из массива 2×5 нельзя сделать новый массив 4×3, 
потому что в старом массиве 10 элементов, а в новом – 12).'''

def my_reshape(arr, col, row):
    result = []
    arShape = arr.shape
    if arShape[0] * arShape[1] == col * row:
        result.append(1)

    return np.array(result)
